[v] Минимальная функциональность
    [v] Собирается
    [v] Запускается отладка
[v] Способ встраивания сторонних C-либ
    [v] Heatshrink
        [v] Сборка с остальной системой
        [v] Создать внешнюю либу, которая использует C под капотом
        [v] Собрать с либой, протестировать
[v] Начальная конфигурация клоков MCU
    [v] Найти правильную реализацию HAL
        tm32l4xx-hal, features = ["stm32l4x3", "rt"]
    [v] Разобраться как взаимодействовать с API
        use stm32l4xx_hal::stm32;

[v] "Перешагивать" код, где нет отладочных символов
    gdb: skip -rfu ^core::

[v] USB
    [v] Настрить минимальную сборку
    [v] Разобраться с получением stm32::Peripherals::take()
        unsafe {stm32::Peripherals::steal()}
    [v] Клокинг USB от PLLR (/2)
    [v] Виртуальный COM-порт работает

[x] Частота проца в конфиге FreeRTOS
    \- Переехали на RTIC \-

[v] Разобраться с cargo embed
    Смотри полную справку в обсидиане
    [v] Config: `.embed.toml`
    [v] Прошивка
    [v] Логирование: `rtt-target`
    [v] Отладка

[v] USB Mass Storage
    https://github.com/cs2dsb/stm32-usb.rs/tree/master/firmware/usbd_mass_storage
    [v] Выбрать VID/PID => 0x0483/0x5720
    [v] Пример запускается, но пока с заглушкой вместо чтения-записи
    [v] Удалось создать Mass Storage + ACM, но работает нестабильно
        [v] Под FreeRTOS бе части работают, но в винде только COM-порт ито как-то странно
        [v] Заставить работать в винде
    [v] Пример c Mass Storage жрет почти все мето в контроллере, почему?
        добавил оптимизацию 1 уровня - размер уменьшился в 2 раза `[profile.dev]/opt-level = 1`
    [x] Проверить распознает ли винда диск Mass Storage
        Не работает, вероятно проблема в "string descriptor 0 read error: -71"
    [x] RTIC Запуск задачи вне контекста прерывания
        Все задачи RTIC - это прерывания

[v] defmt : https://ferrous-systems.com/blog/defmt/
    Множественные изменение в настройках сборки

[v] Определить, оставляем RTIC или FreeRTOS 
    Выбрана FreeRTOS

[v] Привезти проект в порядок
    [v] Убрать варнинги от названий FreeRTOS
    [v] Вынести сервисный код в модули
    [v] Привезти в порядок хуки `defmt::panic!()`
    [v] Настроить зависимость от heatshrink-rust как подкаталог
    [v] Проверить конфиг FreeRTOS
        [v] configCPU_CLOCK_HZ <= from config
        [v] configUSE_MALLOC_FAILED_HOOK = 1
        [v] configUSE_TICKLESS_IDLE = 1 -> configUSE_LOBARO_TICKLESS_IDLE = 1
        [x] configPRIO_BITS - ?
    [v] Прерывания USB будит поток-обработчик
            use FreeRTOS wait-notify

[v] Определение режима работы в зависимости от того, включен ли USB
    [v] Определение, включен-ли USB
        [v] Мониторинг через pwr.sr2.PVMO1, делитель R2-R10 больше не нужен
        [v] Если не включен - не запускать драйвер
    [_] Различная настройка клоков для разных режимов
        Медленный режим - 12MHz (HSE => CPU) 
        Быстрый: (HSE = 12 / 3 40 / 2 => 80 => CPU), (HSE= 12 / 3 24 / 2 => PLLSAI1Q => USB)
        [v] Частоты установлены
        [x] Вместо rcc.cfgr.freeze использовать свою реализацию, посколькоу оно не даёт 
            возможности напрямую подать с HSE в CPU
    [v] FreeRTOS будет настроен на медленный режим (12MHz), в быстром тики будут идти чаще.
    [v] Трейт для режимов работы
        Поскольку полиморфизм очень странно себя ведет, то виртуальные функции юзать лучше не
        надо, генерики и компайл-тайм полиморфизм!

[v] Поток мониторинга
    [v] Краш при попытке malloc() - проверить объем памяти проца
        [v] Defmt не влияет
        [v] ломается цепочка блоков аллокатора
        [v] Прерывание USB не при чем
        [v] Запись идет в функции vTaskGetInfo() pxTaskStatus->uxBasePriority = 1; pxTaskStatus->ulRunTimeCounter = 0; pxTaskStatus указывает в неправильное место!
        [v] Проверить размеры структур
            Структура FreeRtosTaskStatusFfi Rust не соответствует структуре xTASK_STATUS С
            [x] Найти и переключиться на правильную версию FreeRTOS
            [v] Форкнута библиотека freertos-rust  пофикшено там, создан issue https://github.com/lobaro/FreeRTOS-rust/issues/15 
    [v] Отладить вычисление задержки на сон потока мониторинга
        [v] Спецфункция-врапер
    [v] Лог и неспящий FreeRTOS только в режиме debug
        [v] Раздельные конфигурации
        [v] Раздельные FreeRTOSConfig.h
        [v] vApplicationIdleHook только для отладочного режима
    [v] Тест Релиз-сборки
    [x] Мониторинг в отдельный канал RTT, сериализовать FreeRtosSchedulerState
        Есть спец-либа defmt\-rtt\-target, но она для defmt 0.1, одифицировать слишком сложно
    [v] Настроить линкер так, чтобы _SEGGER_RTT не прыгала
        Сложно. Будем вычислять на лету
        [v] Скрипт
    [v] cargo-make
        [v] Задачи - Makefile.toml
        [v] add to Readme
    [v] Статус FreeRtos - вывод за 1 команду, чтобы не было разделений.
        [x] Радобраться как печатается структура с вложенными полями.
        [v] Печать сборкой длинной строки в памяти

[v] Virtual fat
    [v] Сборка
        [v] strlen() missing
            Добавлена реализация на Rust
    [v] Чтение
    [x] Запись
        Недопилено в библотеке
    [v] Работает В Windows
        [v] SCSI: Rest ready - no answer
        [v] Форк библиотеки usbd_scsi
            [v] Встроить субмодулем
        [v] Команда 0x23 
            [v] Исправлен парсинг
            [v] Создан ответ
        [v] sdc: p1 size 82 extends beyond EOD, enabling native capacity
            https://wi-cat.ru/forums/topic/133/#postid-1602
            [v] Поле disk_sectors структуры stm32_usb_self_writer::threads::storage.ctx не является размером диска, нужно добавлять значение stm32_usb_self_writer::threads::storage.ctx.priv_.boot_lba
        [v] Решено: Смотри ZLP
    [v] BOS Descriptor: Response data (unknown descriptor type 15): 050f0c000107100200000000
        Согласно Universal Serial Bus 3.0 Specification, пункт 9.6.2.1:
            05 - длина заголовка дескриптора в байтах
            0f - BOS Descriptor
            0c00 - обзаяя длина всего десккриптора
            01 - 1 дескриптор в пакете:
                07 - размер этого дескриптора в байтах
                10 - тип дескриптора - "DEVICE COMPABILITY"
                02 - константа "Universal Serial Bus 3.0 Specification"
                00 00 00 00 - бит 1 == 0 - Universal Serial Bus 3.0 Specification не поддерживается
    [v] Device qualifier: Empty response
        [v] отсутсвует в либе, делается отлуп (reject)
            Дискриптор должен сообщить хосту как он хочет работать на большей скорости, а поскользу устройство не может - то и дескриптор не нужен:
            https://www.keil.com/pack/doc/mw/USB/html/_u_s_b__device__qualifier__descriptor.html
    [v] Endpoint descriptor: Interval == 0
        Значение только для изохорного и Interrupt ржимов: с каким периодом опрешивать конечную точку точку в единицах базового интервала USB. Игнорируется для остальных типов конечных точек
    [v] Почему кард-ридер получает запросы через USB ?.?.2, а ответ посылает через ?.?.1, тогда 
            как наше устройство все через ?.?.1 ?
            Ответ: Кард-ридер юзает точку 0x81 (IN) и 0x02 (OUT), а наш девайс 0x81 (IN) и 0x01 (OUT)
            [v] А так точно можно?
                Да можно, судя по таблице выделения памяти конечным точкам для каждой есть независимый
                Указатель USB_ADDRn_\[RT\]X и размер буфера USB_COUNTn_\[RT\]X
    [v] USB_COUNTn_RX - таблица
            Это делается в stm32_usbd::endpoint::set_out_buf()/set_in_buf()
    [v] Почему не работает с 8-битным доступом `EP_MEMORY_ACCESS_2X16 = false`? должно быть
            медленнее, но не ломаться совсем, нет? Не получается запросить даже дискриптор устройства.
            Неверно заполняется таблица указателей на буфера конечных точек: значения записываются как
            будто их адреса в 2 раза больше. На лицо неверная адресация. оставляем `EP_MEMORY_ACCESS_2X16 = true`
    [v] Для устройств Full Speed можно иметь размер конечных точек типа Bulk только 8, 16, 32 или 64
            байта, поэтому 256 и отваливается в ошибку -EOVERFLOW
    [v] Проверить, нет ли неопознанных команд
        [v] парсинг - Нет
        [v] Обработка - Нет
    [v] Обнаружено расхождение: в Windows не присылается пакет показывающий успех выполнения чтения
            Из-за этого драйвер не может определтить прошло-ли чтение
        [v] Определение проблемы - Вместо пакета подтвеждения присылается пакет ZLP 
                только при повторном запросе присылается верный пакет, Linux игнорирует проблему.
        [v] Закостылить.
            В библиотеку `lib/stm32-usb.rs/firmware/usbd_bulk_only_transport` обавлена фича, запрещающая
            отправку ZLP, фича прокидывается через библиотеку `lib/stm32-usb.rs/firmware/usbd_scsi`.
    [v] Привезти исходный код в порядок после тестов
        [v] Убрать лишние изменения из библиотеки stm32-usb.rs
        [v] Убрать лишние изменения из библиотеки emfat
        [v] Убрать отладочный код
    
[v] Composite device: Mass Storage + VCP
    [v] Разобраться, что происходит, если не создавать композит вообще
        LINUX: все работает
        Windows: Mass Storage работает, VCP - нет
        Если посмотреть на дискрипторы, то:
        ```
        # несущественные поля опущены
        CONFIGURATION DESCRIPTOR # шапка
            wTotalLength: 90 # общая длина в байтах
            bNumInterfaces: 3 # 3 интрфейса
        # это работает
        INTERFACE DESCRIPTOR (0.0): class Mass Storage
            bInterfaceNumber: 0 # номер интерфейса
        # использует 2 конечные точки на вход и выход
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x01  OUT  Endpoint:1
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x81  IN  Endpoint:1
        # тут не хватает Interface Association Descriptor
        # -- Это не работает --
        # Это интерфейс управления CDC Control
        INTERFACE DESCRIPTOR (1.0): class Communications and CDC Control
            bInterfaceNumber: 1 # номер интерфейса
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        # 1 конечная точка управления CDC, одна от девайса к хосту, хост 
        # периодически читает её чтобы узнать состояние устройства, 
        # и далее что-то передает или читает из CDC-Data
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x82  IN  Endpoint:2
        # Это интерфейс данных CDC-Data
        INTERFACE DESCRIPTOR (2.0): class CDC-Data
            bInterfaceNumber: 2 # номер интерфейса
        # И его конечные точки
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x83  IN  Endpoint:3
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x03  OUT  Endpoint:3
        ```
        Винда ругается, мол "Указано несуществующее устройство", по видимому не хватает,
        как раз Interface Association Descriptor перед class Communications and CDC Control
    [v] Изучить процесс отправки дескрипторов
        Оказывается, все в либе уже есть, нужно было лишь включить этоу возможность
        `UsbDeviceBuilder::composite_with_iads()` и в `UsbDevice<T>::poll(&mut[...])` 
        сувать список ранее созданных интерфейсов в порядке регистрации.
        После этого появляется заполненый Interface Association Descriptor в нужном месте.
    [v] Наростение периода неудачного пулинга *2
        [v] Прерывание происходит очень часто на самом деле, поэтому скалирование задержки не имеет смысла
            Сделаем навсегда до прерывания
            Сразу спала нагрузка на процессор потоком USB до <1%

[_] protobuf
    [v] Попытка поспользоваться nanopb
        [v] Генератор
            [v] Код генератора на питоне, необходимо тащить питоновские скрипты с собой
                Упакуем их в бинарь https://stackoverflow.com/a/47889785
            [x] Плагин генератора надо еще собирать - не нужно
            [v] Работает
            [v] Нативная либа собирается
    [v] ядро nanopb
        [v] Враперы API
    [v] поток обработки Protobuf
        [v] Дедлок: поток usbd пулит стек usb и получает информацию, что пришли данные на конечную току
            виртуального com-порта. pool() самого порта путой. Выходим из главного pool() с true
            а раз так то заходим в него еще раз и вновь имеем, что данные не забраны, опять результат true
            А поскольку usbd имеет максимальный приоритет, то он пулит вечно и не дает шанса обработчику
            все-таки забрать свои данные.
                Форкаем либу и добавляем чтение из конечной точки в кольцевой буфер через pool()
        [v] Наладить обработку сообщений
    [v] Заполнить протокол обмена
        [v] Настройки
            [v] Коэфициенты P-16 T-5
            [v] Неверное энкодирование массива f32 информация о поле не верна
                Добавлен метод кодирования поля, f32 кодируется как variant
            [v] Определение полного количества настраиваемых фич
                [v] Info
                    1. HW_Version/SW_Version - U32
                    2. Флаг несиправности каналов - bool[]
                    3. Флаги выхода за рабочий диопазон - bool[]
                    4. Флаги выхода за рабочий диопазон - bool[]
                    5. Флаг перегрева/передава/перегрева электроники - bool[]
                [v] Config
                    1. Serial - RW (U32)
                    2. Включение канала давления/температуры/измерения питания/температура процессора - bool[]
                    3. Рабочие диопазоны давлений/температур/питаний - f32
                    4. Коэфициенты - f32[]
                    5. Значение опорной частоты - U32
                    6. Пароль - строка\[10\]
                    7. Дата последней калибровки (ДДММГГГГ)
                    8. Коррерция 0 по температуре и давлению - RW (f32)
                    9. Конфигурация записи: {
                        BaseInterval - базовый такт записи, в мс
                        PWriteDevider - записывать давление каждые N BaseInterval-ов
                        TWriteDevider - записывать давление каждые M TWriteDevider-ов
                    }
                    10. Стартовая задержка записи после включения питания - (секунд) U32
                    11. Ед. изм. давления
                [v] Выходные значения
                    1. Измеренные давление и температура - f32
                    2. Температура электроники - f32
                    3. Нарпяжение на батарее - f32
                    4. "Сырые" отладочные значения (Target/result/ADC) - U32
                [v] Команды флеш
                    1. Размер стринцы памяти
                    2. Количество доступных страниц Flash для записи
                    3. Количество занятых страниц
                    4. Сброс флагов мониторинга перегрева/передава/перегрева
                    5. Очистка флешки
                [v] Установка пароля
                    1. Новый пароль
            [v] Реорганизация файла protobuf_server.rs
            [v] Код обработки сообщений
            [v] Обновить биндинги в соответствии новым протоколом
            [v] Обновить device_info::fill_info() в соответсвии с новым протоколом
            [v] Разрешение мониторинга перегрева/передава (критические значения != NAN)
    [_] Заполнить карту в KalibratorGUI
        [v] минимальное соединение работает
        [v] Заменить отправку стримом буферизированной отправкой, гую не очень нравится порезанное на 
            куски сообщение
        [v] Выход за рабочий диопазон/Критический перегрев-передав
        [_] Спец-соманды
            [_] Смена пароля
            [_] Очистка памяти
            [_] Сброс мониторинга
        [v] Заполнить названия ячеек
        [v] Выходное значение Vbat в В.
    [v] Тестирование
    [v] Защищенные паролем значения
    [v] Передача файла опций плагину nanopb 
        Через `--nanopb_opt=--options-file=/path/to/file.option`
    [v] Перепривязать методы от I/OOStream на pb_i/ostream_s
    [v] Настройки
        [v] Хранилище
        [v] CRC
        [v] Интерфейс с protobuf
            [v] Чтение
            [v] Запись
            [v] Ошибки
                [v] ID устройства
                [v] Версия протокола
                [v] Ограничения на значения полей
            [v] Отладка
        [v] Псефдофайл, содержащий конфигурацию
            [v] Печатать не все настройки, скипать пароль, например
                `#[serde(skip_serializing)]`
        [v] Некоторые настройки не должны сохраняться
    [v] Замена nanopb на https://github.com/tokio-rs/prost
        [v] Добавлено к сборке
        [v] Процессинг заголовка
        [v] Парсинг тела сообщения
        [v] Пбработка тела
        [v] Построение ответа
        [v] Сериализация
        [v] Замена чтения и записи nanopb
        [v] Удаление nanopb

[v] Мониторинг состояния кучи
    [v] отключаемый через фичу
[x] Сериализация/Десериализация настроек при помощи protobuf
    Передумал, не тронь - и так работает
[v] log: секунды.милисекунды
[x] cargo::track()
    Не гуглится. Где я это видел?
[v] Псевдофайл, содержащий инфу о занятом месте
[v] Макрос, делающий null-terminated строки
[v] Менеджаер прерываний - обертка чтобы не зависеть от конкретного контроллера
[v] Экономия процессорного времени
    [v] Пробуждать поток protobuf только если usb.pool() == true
        Проблемы не было, просто в отстутвие работающих потоков ломался мониторинг defmt
        На отладку добавлен специальный псевдо-IDLE поток
    [v] Подбор переиода сна usbd
        Бесконечность
[v] Генерация конфига FreeRTOS
    [v] Поля, зависимые от билда
    [v] Шаблон
    [v] Генератор

[v] Частотомеры
    [x] Использовать готовый C-код из CAN
        Слишком много зависимостей, в том числе HAL
    [v] Частотмер на Rust
        Приоритет событий:
            1. Транзакция DMA
            2. Прерывание завершения транзакции DMA
            3. Прерывание перерполнения мастер-счетчика
        [v] Мастер-счетчик
            [v] Считает
            [v] TIMx_CR1:UIFREMAP 
                Судя по описанию, когда =1 битик TIMx_SR:UIF копируется в
                бит 31 TIMx_CR1:CNT и будет захвачен DMA. Если он будет 1 можно будет судить,
                что на момент захвата прерывание стриггерилось но еще не обработано, а следовательно
                экстендер содержит значение на 1 меньше чем правда!
            [x] Попробовать LPTIM аймер как опору
                Нет бита, аналогичного UIFREMAP
            [v] Маестер счетчик 32 бита (16+16), соответственно он должен преполняться с периодом 
                1/80кк 2^32 = 53,6 c
            [v] Снизить базовую частоту делителем APB1 (/8) (может меньше из-за USB)
            [v] Низкий приоритет прерывания мастер-счетчика
                ```
                Согласно моим рассуждениям, у прерывания мастер-счетчика должен быть низкий приоритет
                А у рабочих счетчиков выше, однако защитить инкриминт расширителя и сбро флага прерывания
                критической секцией. С другой стороны, при при обновлении захваченного значения
                Учинывать был ли бит UIFREMAP, и если был, и сейчас флаг прерывания мастер счетчика установлен
                то увеличить считать значение расширителя +1, иначе - нет.
                ```
                [v] Критичекая секция
                [v] Обновление обновлятора значения
            [v] Подключение Входных каналов
                [v] Пины питания генераторов
            [v] Начала и конец измерительного цыкла вместо циклической работы
                Старт: Счетчик остановлен, ставим значение Reload - 1,  TIMx_CR1.OPM = 0
                Таймер тосчитывает 1 импульс и сбрасывается -> DMA -> Старт захвачен -> Прерывание TIMx_CR1.OPM = 1
                Счетчик отсчитывает заданное количество входных импульсов
                Переполнение -> DMA -> Стоп захвачен -> аймер остановился автоматически
                [v] Изменить старт таким образом, чтобы он не реагировал на попытку запустить 
                    работающий счетчик
                [v] Старт убирает бит TIMx_CR1.OPM и TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
                [v] В зависимости от состояния бита TIMx_CR1.OPM генерировать разное событие при вызове колбэка
                    после DMA
                [v] В состоянии Start установить бит TIMx_CR1.OPM
            [v] Проверить цыклический режим после обнаружения неисправности с захватом
                Тоже работает, надо решить какой режим использовать
                [x] Режим с остановкой более управляем, так как четко захвачено начало и конец,
                    а между ними можно *Четкосменить таргет
                [v] В поточном режиме меньше прерываний в 2 раза, но каждое следующее должно иметь достоверный
                    результат предыдущего, то есть после смены таргета нужно все равно начинать c TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
            [v] Определить способ нахождения первого стартового результата
                Пусть этим занимается уже процессор результата, а не счетчик
                [v] Удалить остатки режима старт-стоп
                [v] Заменить метод start() на cold_start() который ставит TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
                [v] Если set_target32() вызывается на работающем счетчика - паника!
    [x] Обнаружена иголка. Значение result: 19991648 -> 200316 = diff|19791332, затем адаптация воостановила.
        [v] Точно известно, что старший бит счетчика отразает действительно-ли счетчик был переполнен и прерывание
            не обработано. Ранее сделанная эвристика надежно не работает.
            [v] Костыль: перезапуск измерения если факт был обнаружен.
            [x] Проанализировать разницу результатов, если она близка к 0xffff +/- 500 (например) делать нужную поправку - ненадежно
    [v] Частота зависит от времени измерения?
        При малых временах измерения частота катастрофически занижается, это занижение тем меньше, чем больше время измерения.
        Обнаружено, что нужно к значению таргета добавлять +1 при вычислении частоты
        [v] Добавить компенсацию в as_target32()
        [?] Таргет давления не опускается ниже 99 при времени измерения < 100 мс
    [v] DMA
        [v] Конфигураци зависит от счетчика к которому подключается канал DMA
        [v] Настройка частотомера - есть расширение навешеное на счетчик, только подходящие
            счетчики имеют такое расширение, остальные не имплиментированы вообще
        [v] В терминах Rust HAL то что в таблице 41. даташита названо Channel это cXs, а то что названо
            CxS - это map
        [v] DMA захватывает значение мастер-счетчика
        [v] Организация вычисления полноценного значеий target и result
        [x] Бит TIMx_CR1.UIFCPY не захватывается DMA почему-то, в принципе он вроде и не нужен
                Получается, можно просто проверить если флаг прерывания мастер-счетчика установлен
                то добавим к расширителю +1.
        [v] Надоело туда-сюда вертеть режим, сделать старт-стоп фчичей
    [v] Процессор датчиков должен знать частоту работы опорного счетчика, а не "магическое число"
    [v] Неавтоматическая адаптация
        [v] Перенос подсчет частоты в FreqmeterController
        [v] Перенос вычисления частоты в impl RawValueProcessor
        [v] Добавить адаптацию
        [v] Процессинг значения возвращает новое значение для адаптации, или None, тогда используется старое
    [v] Обработка потери сиграла на входе
        [v] Таймер отсчитывающий 1,5 времени измерения канала
        [v] Если дошел до конца, посылает событие Timeout(ch)
        [v] В случае получения события ReadyFChannel(ср) сброс этого таймера
        [v] Если получено событие Timeout(ch), рестарт чатсотомера начальный таргет + гвард на время измерения 1.5
    [v] Вывод данных в protobuf
        [v] target / result
        [v] Частоты
        [v] Частотные выходные данныне
        [v] Аналоговые значения АЦП
        [v] Аналоговые величины
    [v] Промежуточные вычисления в double
        [v] Частота
        [v] Давление
        [v] Температура
        [v] Аналог
            [v] Версия 0.6.0 HAL'а не поддерживала ADC API пшлось брать из репозитория
                [v] Изменен механизм задания Пинов I/O и ADC (Если пин с альтернативной функцией, то он задается
                    как выход)
            [v] Все варианты разрешения АЦП кроме 12 бит бессмыслены, поскольку вычисление температуры
                требует на вход 12-битный результат.
        [v] Вывод конвертировать назад в float
    [v] Подготовка к режиму низкого энергопоребления
        Добавить политику, котоая отвечает за процессинг сырых значений в зависимости от режима.

[_] Режим высокой производительнсти
    [v] Обработка частотных каналов
        [v] Отладка
        [v] Запись события выхода за максимальный допустимый предел
            [v] Работает, только если критическое значение не NAN, фильтр мониторинга 
                всегда возвращает false, если лимит - NAN
    [v] Обработка аналоговых каналов
        [v] Напряжеине Vbat
        [v] Температура процессора
            [v] Период измерения температуры процессора = время измерения температуры
            [v] период измерения Vbat = min(время измерения температуры, время измерения давления)
    [v] Снизить базовую чстоту до 40 MHz
    [v] АЦП, почему оно рывками работает?
        [v] Похоже дело в частоте, снижение до 40 МHz все чинит, надо проверить прескейлер
            Добавлен предделитель от базовой частоты
    [v] Пересчет едениц измерения давления
    [v] Корректировка нуля по каналам
    [_] Чтение из Flash
        [v] Чтение из собственной памяти МК
    [_] Вычисление статистики занятого пространства

[_] Режим самописца
    [v] Периферия, требуемая для режима низкого энергопотребления
        [v] rcc
        [v] flash
        [v] pwr
        [v] clocks
        [v] interrupt_controller
        [v] crc
        [v] in_p
        [v] in_t
        [v] en_p
        [v] en_t
        [v] dma1_ch2
        [v] dma1_ch6
        [v] timer1
        [v] timer2
        [v] adc
        [v] adc_common
        [v] vbat_pin
        [v] Обновить клокинг конфиг
        [v] led pin
    [v] Архитектура
        [v] Предварительный "прогрев" генераторов заранее *2 времени измерения
        [v] Отключение генераторов при большой разнице между временем измерения и периодом записи
    [_] Запись
        [v] Подготовка данных
        [v] Сжатие страниц
        [v] Запись во внутреннюю FLASH MK
            [v] 2 страницы
            [v] 8 страниц
        [_] Запись во flash
    [v] Адаптация
        [v] В случае перехода на новую страницу
        [v] В случае запуска после сна
        [v] Автоадаптация тебует по крайней мере 2 цыкла для получения правильного значения target
            Точность зависит от стартового количества импульсов, поэтому выбор между быстрой адаптацией
            И быстрым стартом
    [_] "Засыпание" в случае большого интервала записи
        [v] Алгоритм засыпания канала
        [v] Проверить, есть ли защита от установки делителя для канала в 0 и базового интервала в 0
            Допилено
        [v] Проверка снятия напряжения
            Fixed: Слишком ранне отключение каналов, прогрев не звершен.
        [v] Канал температуры показывет неадекватное значение - адаптация не проходит
            [v] Запускать канала в 2+ этапа, чтобы полцчить минимальную задержку после включения питания
            [v] Первые ~100ms канал температуры даёт частоту 100kHz, надо увеличить время начальной
                адаптации как минимум до 200мс
        [v] A АЦП выключается между шапками?
            Там было автоотключение после 1 измерения
        [_] Записать 2 страницы в таком режиме и проверить корректность
        [v] Убрать дебаг-псевдо-айдл, в пользу настоящего
            Непонятно почему, но сейчас оно просто работает без костылей

[_] Modbus сервер, как альтернатива Protobuf, не вместе!
    
[v] Переставить компаратор на TLV3012 и попробовать на 1,8 В
[x] Стандартные Vid/Pid чтобы windows7 распознавала CDC/ACM
    [v] Запихать драйвер прямо на виртуальный диск
    [v] Сделать одной функцией любые статические данныне, не только строки
[v] Утечка памяти при сохранении настроек - краш после пары раз
    [v] при отладке поток, который выполняе сохранение делает своеё дело и остается зомби по тому что его ресурсы
        должен подчистить IDLE который на когда не выполняется.
        [v] Перенести сохранение из специального потока в таймер
[v] При малых временах измерения в режиме USB переполнение очереди контроллера измерений
    Множество улучшений и компромиссов, включена фича freqmeter-start-stop по дефолту, с ней лучше работает при
    малых временах измерения. Устойчиво работает на времени измерения 20мс, кратковременный "лаг" при монтировании
    виртуального диска. Приоритет процесса USB приравнен к приоритету процессинга сенсоров
[v] Починить CRC32 тобы оно соответствовало zlib'овскому
    // https://stackoverflow.com/a/48883954
    config
        .input_bit_reversal(BitReversal::ByByte)
        .output_bit_reversal(true)
    Результат инвертировать!

[v] FreqmeterController::enable() Убрать задержку старта, она очень мешает нормальному процессингу.
[v] Пониженное энергопоребление
    [v] Полное отключение - standby
        [v] при заполнеии памяти
        [v] при падении напряжения батарейки ниже минимального питания из настроек
    [v] Обычный режим процессора - Low-power run
        [v] Есть толк
        [v] Снизить частоту процессора, переписсать cfgr.freeze() под конкретные задачи для обоих режимов
            0.5 мА с 1 генератором на привязи @ 3MHz
[_] Флаги критческого превышения параметров
    [_] Регистрация события
    [_] Запись в лог
    [_] Перманентная установка
[v] В релизе падает при инициализации режима датчика, невозможный тергет
    По какой-то причине результат мог быть равен 0, приравнимаем это к потере сигнала и обрабатываем
    сответсвенно
        
[_] Изучить freertos_rust::patterns::compute_task